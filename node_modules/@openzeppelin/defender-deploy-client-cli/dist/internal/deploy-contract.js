"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployContract = void 0;
const fs_1 = require("fs");
async function deployContract(args, client) {
    const buildInfoFileContents = await fs_1.promises.readFile(args.buildInfoFile, 'utf8');
    const deploymentRequest = {
        contractName: args.contractName,
        contractPath: args.contractPath,
        network: args.network,
        artifactPayload: buildInfoFileContents,
        licenseType: args.licenseType,
        constructorBytecode: args.constructorBytecode,
        verifySourceCode: args.verifySourceCode,
        relayerId: args.relayerId,
        salt: args.salt,
        createFactoryAddress: args.createFactoryAddress,
        txOverrides: args.txOverrides,
        metadata: args.metadata,
        origin: args.origin,
    };
    let deployment;
    try {
        deployment = await client.deployContract(deploymentRequest);
    }
    catch (e) {
        if (e.response?.data?.message?.includes('licenseType should be equal to one of the allowed values')) {
            throw new Error(`The licenseType option "${args.licenseType}" is not valid for block explorer verification. See https://etherscan.io/contract-license-types for supported values and use the string found in brackets, e.g. "MIT"`);
        }
        else {
            throw e;
        }
    }
    while (deployment.status !== 'completed' && deployment.status !== 'failed') {
        console.log(`Waiting for deployment id ${deployment.deploymentId} to complete...`);
        await new Promise(resolve => setTimeout(resolve, 5000));
        const deploymentId = deployment.deploymentId;
        deployment = await client.getDeployedContract(deploymentId);
    }
    switch (deployment.status) {
        case 'completed':
            console.log(`Deployment ${deployment.deploymentId} completed.`);
            break;
        case 'failed':
            throw new Error(`Deployment ${deployment.deploymentId} failed.`);
        default:
            throw new Error(`Deployment ${deployment.deploymentId} has unknown status ${deployment.status}.`);
    }
    if (deployment.address === undefined) {
        throw new Error(`Deployment ${deployment.deploymentId} completed but has no address.`);
    }
    return deployment.address;
}
exports.deployContract = deployContract;
//# sourceMappingURL=deploy-contract.js.map