"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFunctionArgs = exports.getApprovalProcess = void 0;
const minimist_1 = __importDefault(require("minimist"));
const client_1 = require("../internal/client");
const utils_1 = require("../internal/utils");
const USAGE_DEPLOY = `${utils_1.USAGE_COMMAND_PREFIX} getDeployApprovalProcess --chainId <CHAIN_ID>`;
const DETAILS_DEPLOY = `
Gets the default deploy approval process configured for your deployment environment on OpenZeppelin Defender.

Required options:
  --chainId <CHAIN_ID>            Chain ID of the network to use.
`;
const USAGE_UPGRADE = `${utils_1.USAGE_COMMAND_PREFIX} getUpgradeApprovalProcess --chainId <CHAIN_ID>`;
const DETAILS_UPGRADE = `
Gets the default upgrade approval process configured for your deployment environment on OpenZeppelin Defender.
For example, this is useful for determining the default multisig wallet that you can use in your scripts to assign as the owner of your proxy.

Required options:
  --chainId <CHAIN_ID>            Chain ID of the network to use.
`;
async function getApprovalProcess(command, args, deployClient, networkClient) {
    const { parsedArgs, extraArgs } = parseArgs(args);
    if (!help(command, parsedArgs)) {
        const network = await getFunctionArgs(command, parsedArgs, extraArgs, networkClient);
        const client = deployClient ?? (0, client_1.getDeployClient)();
        let response;
        switch (command) {
            case 'getDeployApprovalProcess':
                response = await client.getDeployApprovalProcess(network);
                break;
            case 'getUpgradeApprovalProcess':
                response = await client.getUpgradeApprovalProcess(network);
                break;
            default:
                throw new Error(`Unknown command: ${command}`);
        }
        console.log(`Approval process ID: ${response.approvalProcessId}`);
        if (response.via !== undefined) {
            console.log(`Via: ${response.via}`);
        }
        if (response.viaType !== undefined) {
            console.log(`Via type: ${response.viaType}`);
        }
    }
}
exports.getApprovalProcess = getApprovalProcess;
function parseArgs(args) {
    const parsedArgs = (0, minimist_1.default)(args, {
        boolean: [
            'help',
        ],
        string: ['chainId'],
        alias: { h: 'help' },
    });
    const extraArgs = parsedArgs._;
    return { parsedArgs, extraArgs };
}
function help(command, parsedArgs) {
    if (!parsedArgs['help']) {
        return false;
    }
    else {
        switch (command) {
            case 'getDeployApprovalProcess':
                console.log(USAGE_DEPLOY);
                console.log(DETAILS_DEPLOY);
                break;
            case 'getUpgradeApprovalProcess':
                console.log(USAGE_UPGRADE);
                console.log(DETAILS_UPGRADE);
                break;
            default:
                throw new Error(`Unknown command: ${command}`);
        }
        return true;
    }
}
/**
 * Gets and validates function arguments and options.
 * @returns Function arguments
 * @throws Error if any arguments or options are invalid.
 */
async function getFunctionArgs(command, parsedArgs, extraArgs, networkClient) {
    if (extraArgs.length !== 0) {
        throw new Error(`The ${command} command does not take any arguments, only options.`);
    }
    else {
        const networkString = (0, utils_1.getAndValidateString)(parsedArgs, 'chainId', true);
        const network = await (0, utils_1.getNetwork)(parseInt(networkString), networkClient);
        checkInvalidArgs(parsedArgs);
        return network;
    }
}
exports.getFunctionArgs = getFunctionArgs;
function checkInvalidArgs(parsedArgs) {
    const invalidArgs = Object.keys(parsedArgs).filter(key => ![
        'help',
        'h',
        '_',
        'chainId',
    ].includes(key));
    if (invalidArgs.length > 0) {
        throw new Error(`Invalid options: ${invalidArgs.join(', ')}`);
    }
}
//# sourceMappingURL=get-approval-process.js.map