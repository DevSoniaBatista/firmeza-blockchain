"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = void 0;
const minimist_1 = __importDefault(require("minimist"));
const deploy_contract_1 = require("../internal/deploy-contract");
const client_1 = require("../internal/client");
const utils_1 = require("../internal/utils");
const USAGE = `${utils_1.USAGE_COMMAND_PREFIX} deploy --contractName <CONTRACT_NAME> --contractPath <CONTRACT_PATH> --chainId <CHAIN_ID> --buildInfoFile <BUILD_INFO_FILE_PATH> [--constructorBytecode <CONSTRUCTOR_ARGS>] [--licenseType <LICENSE>] [--verifySourceCode <true|false>] [--relayerId <RELAYER_ID>] [--salt <SALT>] [--createFactoryAddress <CREATE_FACTORY_ADDRESS>] [--gasLimit <GAS_LIMIT>] [--gasPrice <GAS_PRICE>] [--maxFeePerGas <MAX_FEE_PER_GAS>] [--maxPriorityFeePerGas <MAX_PRIORITY_FEE_PER_GAS>] [--metadata <METADATA>] [--origin <ORIGIN>]`;
const DETAILS = `
Deploys a contract using OpenZeppelin Defender.

Required options:
  --contractName <CONTRACT_NAME>  Name of the contract to deploy.
  --contractPath <CONTRACT_PATH>  Path to the contract file.
  --chainId <CHAIN_ID>            Chain ID of the network to deploy to.
  --buildInfoFile <BUILD_INFO_FILE_PATH>  Path to the build info file containing Solidity compiler input and output for the contract.

Additional options:
  --constructorBytecode <CONSTRUCTOR_BYTECODE>  0x-prefixed ABI encoded byte string representing the constructor arguments. Required if the constructor has arguments.
  --licenseType '<LICENSE>'       License type to display on block explorers for verified source code. See https://etherscan.io/contract-license-types for supported values and use the string found in brackets, e.g. 'MIT'
  --verifySourceCode <true|false>  Whether to verify source code on block explorers. Defaults to true.
  --relayerId <RELAYER_ID>        Relayer ID to use for deployment. Defaults to the relayer configured for your deployment environment on Defender.
  --salt <SALT>                   Salt to use for CREATE2 deployment. Defaults to a random salt.
  --createFactoryAddress <CREATE_FACTORY_ADDRESS>  Address of the CREATE2 factory to use for deployment. Defaults to the factory provided by Defender.
  --gasLimit <GAS_LIMIT>          Maximum amount of gas to allow the deployment transaction to use.
  --gasPrice <GAS_PRICE>          Gas price for legacy transactions, in wei.
  --maxFeePerGas <MAX_FEE_PER_GAS>  Maximum total fee per gas, in wei.
  --maxPriorityFeePerGas <MAX_PRIORITY_FEE_PER_GAS>  Maximum priority fee per gas, in wei.
  --metadata '<METADATA>'         Use this to identify, tag, or classify deployments. See https://docs.openzeppelin.com/defender/module/deploy#metadata. Must be a JSON string, for example: --metadata '{ "commitHash": "4ae3e0d", "tag": "v1.0.0", "anyOtherField": "anyValue" }'
  --origin <ORIGIN>               The client that made the deployment. For internal use only. Only 'Foundry' or 'SDK' are supported. Defaults to 'SDK'.
`;
async function deploy(args, deployClient, networkClient) {
    const { parsedArgs, extraArgs } = parseArgs(args);
    if (!help(parsedArgs)) {
        const functionArgs = await getFunctionArgs(parsedArgs, extraArgs, networkClient);
        const client = deployClient ?? (0, client_1.getDeployClient)();
        const address = await (0, deploy_contract_1.deployContract)(functionArgs, client);
        console.log(`Deployed to address: ${address}`);
    }
}
exports.deploy = deploy;
function parseArgs(args) {
    const parsedArgs = (0, minimist_1.default)(args, {
        boolean: [
            'help',
            'verifySourceCode',
        ],
        string: ['contractName', 'contractPath', 'chainId', 'buildInfoFile', 'licenseType', 'constructorBytecode', 'relayerId', 'salt', 'createFactoryAddress', 'gasLimit', 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas', 'metadata', 'origin'],
        alias: { h: 'help' },
        default: { verifySourceCode: true },
    });
    const extraArgs = parsedArgs._;
    return { parsedArgs, extraArgs };
}
function help(parsedArgs) {
    if (!parsedArgs['help']) {
        return false;
    }
    else {
        console.log(USAGE);
        console.log(DETAILS);
        return true;
    }
}
/**
 * Gets and validates function arguments and options.
 * @returns Function arguments
 * @throws Error if any arguments or options are invalid.
 */
async function getFunctionArgs(parsedArgs, extraArgs, networkClient) {
    if (extraArgs.length !== 0) {
        throw new Error('The deploy command does not take any arguments, only options.');
    }
    else {
        // Required options
        const contractName = (0, utils_1.getAndValidateString)(parsedArgs, 'contractName', true);
        const contractPath = (0, utils_1.getAndValidateString)(parsedArgs, 'contractPath', true);
        const networkString = (0, utils_1.getAndValidateString)(parsedArgs, 'chainId', true);
        const network = await (0, utils_1.getNetwork)(parseInt(networkString), networkClient);
        const buildInfoFile = (0, utils_1.getAndValidateString)(parsedArgs, 'buildInfoFile', true);
        // Additional options
        const licenseType = (0, utils_1.getAndValidateString)(parsedArgs, 'licenseType');
        const constructorBytecode = parsedArgs['constructorBytecode'];
        const verifySourceCode = parsedArgs['verifySourceCode'];
        const relayerId = (0, utils_1.getAndValidateString)(parsedArgs, 'relayerId');
        const salt = (0, utils_1.getAndValidateString)(parsedArgs, 'salt');
        const createFactoryAddress = (0, utils_1.getAndValidateString)(parsedArgs, 'createFactoryAddress');
        const txOverrides = {
            gasLimit: parseNumberOrUndefined((0, utils_1.getAndValidateString)(parsedArgs, 'gasLimit')),
            gasPrice: parseHexOrUndefined((0, utils_1.getAndValidateString)(parsedArgs, 'gasPrice')),
            maxFeePerGas: parseHexOrUndefined((0, utils_1.getAndValidateString)(parsedArgs, 'maxFeePerGas')),
            maxPriorityFeePerGas: parseHexOrUndefined((0, utils_1.getAndValidateString)(parsedArgs, 'maxPriorityFeePerGas')),
        };
        const metadata = getAndValidateJsonString(parsedArgs, 'metadata');
        const origin = getAndValidateOrigin(parsedArgs, 'origin');
        checkInvalidArgs(parsedArgs);
        return { contractName, contractPath, network, buildInfoFile, licenseType, constructorBytecode, verifySourceCode, relayerId, salt, createFactoryAddress, txOverrides, metadata, origin };
    }
}
function checkInvalidArgs(parsedArgs) {
    const invalidArgs = Object.keys(parsedArgs).filter(key => ![
        'help',
        'h',
        '_',
        'contractName',
        'contractPath',
        'chainId',
        'buildInfoFile',
        'licenseType',
        'constructorBytecode',
        'verifySourceCode',
        'relayerId',
        'salt',
        'createFactoryAddress',
        'gasLimit',
        'gasPrice',
        'maxFeePerGas',
        'maxPriorityFeePerGas',
        'metadata',
        'origin',
    ].includes(key));
    if (invalidArgs.length > 0) {
        throw new Error(`Invalid options: ${invalidArgs.join(', ')}`);
    }
}
function parseHexOrUndefined(value) {
    if (value !== undefined) {
        // If not a hex string, convert from decimal to hex as a string
        if (!value.startsWith('0x')) {
            return '0x' + Number(value).toString(16);
        }
        else {
            return value;
        }
    }
    else {
        return undefined;
    }
}
function parseNumberOrUndefined(value) {
    if (value !== undefined) {
        return Number(value);
    }
    else {
        return undefined;
    }
}
function getAndValidateJsonString(parsedArgs, option) {
    const value = (0, utils_1.getAndValidateString)(parsedArgs, option);
    if (value !== undefined) {
        try {
            return JSON.parse(value);
        }
        catch (e) {
            throw new Error(`Failed to parse ${option} option as JSON: ${e.message}`);
        }
    }
    else {
        return undefined;
    }
}
function getAndValidateOrigin(parsedArgs, option) {
    const value = (0, utils_1.getAndValidateString)(parsedArgs, option);
    const supportedOrigins = ['Foundry', 'SDK'];
    if (value !== undefined) {
        if (!supportedOrigins.includes(value)) {
            throw new Error(`Option --${option} only supports 'Foundry' or 'SDK'`);
        }
        return value;
    }
    else {
        return undefined;
    }
}
//# sourceMappingURL=deploy.js.map